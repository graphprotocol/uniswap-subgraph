# Stores values from the Uniswap factory
type Uniswap @entity {
  id: ID!                             # Always 1 for v1 Uniswap

  exchanges: [Exchange!]! @derivedFrom(field: "factoryID")
  exchangeCount: Int!

  # Aggregated statistics
  totalVolumeInEth: BigDecimal!       # Volume just on eth, so we don't double count
  totalVolumeUSD: BigDecimal!         # Accumulated at each trade, not just calculated off totalVolumeInEth, making it more accurate
  totalLiquidityInEth: BigDecimal!    # 2 * SUM(exchanges.ethLiquidity), since tokenLiquiduity = ethLiquidity value
  totalLiquidityUSD: BigDecimal!
  
  # Event totals
  totalAddLiquidity: BigInt!
  totalRemoveLiquidity: BigInt!
  totalTokenBuys: BigInt!
  totalTokenSells: BigInt!

  exchangeHistoryEntityCount: BigInt!
  txCount: BigInt!
}

# Stores values from Uniswap exchanges
type Exchange @entity {
  id: ID!                           # Exchange address

  # Token details
  tokenAddress: Bytes!
  tokenName: String!
  tokenSymbol: String!
  tokenDecimals: Int!

  fee: BigDecimal!                  # Always 0.3% for v1 Uniswap
  version: Int!                     # v1 only right now
  startTime: Int!                   # Time exchange was created
  ethLiquidity: BigDecimal!         # Equals the liquidty provided. Will likely be different than ethBalance
  tokenLiquidity: BigDecimal!       # Equals the token liquidity provided. Will likely be different thatn tokenBalance
  ethBalance: BigDecimal!           # Equals the ether balance of the contract
  tokenBalance: BigDecimal!         # Equals the token balance of the contract
  combinedBalanceInEth: BigDecimal! # Equal to ethBalance + (tokenBalance/price). Stored to simplify users calculating their own personal return. because the ratio may have changes a lot in one direction
  combinedBalanceInUSD: BigDecimal! # Equal to combinedBalanceInUSD * DAI/ETH
  ROI: BigDecimal!                  # ROI for the exchanges lifetime.
  totalUniToken: BigDecimal!        # Count of the underlying unitokens that represent liquidity provided ownership

  # Counting Events
  addLiquidityCount: BigInt!        # Count the number of times liquidity has been added
  removeLiquidityCount: BigInt!     # Count the number of times liquidity has been removed
  buyTokenCount: BigInt!            # Count the number of times the tokens been bought
  sellTokenCount: BigInt!           # Count the number of times the tokens been sold

  # Price values using eth
  lastPrice: BigDecimal!            # The last trade price
  price: BigDecimal!                # Price is the total amount of tokens that equal one ETH. i.e. if ETH was 100 USD, price for DAI would be 100
  tradeVolumeToken: BigDecimal!     # Total tokens traded EVER
  tradeVolumeEth: BigDecimal!       # Total eth traded EVER
  totalValue: BigDecimal!           # totalValue is accumulation of trade price * trade volume. i.e. TV = tokensSold * priceTokensSold
  weightedAvgPrice: BigDecimal!     # Avg price of all trades since inception. WAP = totalValue / totalVolume

  # Price values using usd
  lastPriceUSD: BigDecimal!         # The last trade price in USD
  priceUSD: BigDecimal!             # USD / token
  weightedAvgPriceUSD: BigDecimal!  # weightAvgPriceUSD = ( $1 of ETH in ETH ) / weightedAvgPrice

  # Fields used to help derived relationship
  factoryID: String!                # used for @derivedFrom of Factory
  tokenHolders: [UserExchangeData!]! @derivedFrom(field: "exchangeAddress") # Relationship to show all token holders on the exchange
  txs: [Transaction!]! @derivedFrom(field: "exchangeAddress")               # Relationship to show all txs on the exchange
}

type User @entity {
  id: ID! # user eth adddress

  exchangeBalances: [UserExchangeData!]! @derivedFrom(field: "userAddress")
  txs: [Transaction!]! @derivedFrom(field: "userAddress")
}

type UserExchangeData @entity {
  id: ID!                      # ID is concatenation of token and user addr. i.e. 0xahiow4-0xkashkd34....

  userAddress: Bytes!          # used for @derivedFrom of User
  exchangeAddress: Bytes!      # used for @derivedFrom of TrackedExchange

  # Liquidity Provider Data
  ethDeposited: BigDecimal!    # where negative means eth was exchanged for tokens
  tokensDeposited: BigDecimal! # Where negative means tokens were exchanged for eth
  ethWithdrawn: BigDecimal!
  tokensWithdrawn: BigDecimal!
  uniTokenBalance: BigDecimal!

  # Trading Data
  # Note - Fee is always charged in what the user is paying with. i.e. you buy eth by paying in token. Fee is in token
  # Note - ethBought, ethSold, tokensBought, and tokensSold are effected by a basic Transfer
  ethBought: BigDecimal!
  ethSold: BigDecimal!
  tokensBought: BigDecimal!
  tokensSold: BigDecimal!
  ethFeesPaid: BigDecimal!
  tokenFeesPaid: BigDecimal!
  ethFeesInUSD: BigDecimal!
  tokenFeesInUSD: BigDecimal!
}

type Transaction @entity {
  id: ID! # 0, 1, 2....

  tx: Bytes!
  event: String!
  block: Int!
  timestamp: Int!

  tokenAddress: Bytes!
  tokenSymbol: String!
  exchangeAddress: Bytes!

  user: Bytes!
  ethAmount: BigDecimal!
  tokenAmount: BigDecimal!
  fee: BigDecimal!
}

##### Below are entities specifically for uniswap historical data #####

# Historical data for each event of each exchange. Useful for creating graphs and data analysis
type ExchangeHistoricalData @entity {
  id: ID!

  tokenAddress: Bytes!
  tokenSymbol: String!
  exchangeAddress: Bytes!           # Uniswap exchange address

  type: EventType!
  timestamp: Int!

  ethLiquidity: BigDecimal!         # Equals the liquidty provided. Will likely be different than ethBalance
  tokenLiquidity: BigDecimal!       # Equals the token liquidity provided. Will likely be different thatn tokenBalance
  ethBalance: BigDecimal!           # Equals the ether balance of the contract
  tokenBalance: BigDecimal!         # Equals the token balance of the contract
  combinedBalanceInEth: BigDecimal! # Equal to ethBalance + (tokenBalance/price). Stored to simplify users calculating their own personal return. because the ratio may have changes a lot in one direction
  combinedBalanceInUSD: BigDecimal! # Equal to combinedBalanceInUSD * DAI/ETH.  USD price at time of transaction
  ROI: BigDecimal!                  # ROI for the exchanges lifetime.
  totalUniToken: BigDecimal!        # Count of the unilying unitokens that represent liquidity provided ownership
  tokenPriceUSD: BigDecimal!        # USD / token. USD price at time of transaction
  price: BigDecimal!                # Price is the total amount of tokens that equal one ETH. i.e. if ETH was 100 USD, price for DAI would be 100
  tradeVolumeToken: BigDecimal!     # Total tokens traded EVER. i.e. cumulative
  tradeVolumeEth: BigDecimal!       # Total eth traded EVER. i.e. cumulative
  feeInEth: BigDecimal!
}

# Data accumulated and condensed into day stats for each exchange
type ExchangeDayData @entity {
  id: ID!                      # token address concatenated with unix date (Nov 2nd 2018 is 17837)

  date: Int!                   # starts on 1541116800 (Nov 2nd 2018 00:00:00). all dates must start on 00:00:00
  exchangeAddress: Bytes!
  ethBalance: BigDecimal!      # Eth balance at last event within the day
  tokenBalance: BigDecimal!    # Token balance at last event within the day
  marginalEthRate: BigDecimal! # tokenBalance / ethBalance
  ethVolume: BigDecimal!       # Cumulative volume throughout the day
  ROI: BigDecimal!             # ROI for the exchange at the last event within the day
  tokenPriceUSD: BigDecimal!   # USD token price at last event within the day
  totalEvents: BigInt!
}

# Note - No fee to provide liqidity
type LiquidityEvent @entity {
  id: ID! # 0, 1, 2... as txhashes can contain multiple events

  type: EventType!
  provider: Bytes!

  # Monetary values
  ethAmount: BigDecimal!
  tokenAmount: BigDecimal!

  # Block data
  timestamp: Int!
  txhash: Bytes!
  block: Int!

  # Token details
  tokenAddress: Bytes!
  name: String!
  symbol: String!
  decimals: Int!
  exchangeAddress: Bytes!
}

type TradeEvent @entity {
  id: ID! # 0, 1, 2... as txhashes can contain multiple events

  type: EventType!
  buyer: Bytes!

  # Monetary Values. Positive or negative determined by the TradeType
  eth: BigDecimal!
  token: BigDecimal!
  tokenFee: BigDecimal!
  ethFee: BigDecimal!

  # Block data
  timestamp: Int!
  txhash: Bytes!
  block: Int!

  # Token details
  tokenAddress: Bytes!
  name: String!
  symbol: String!
  decimals: Int!
  exchangeAddress: Bytes!
}

enum EventType {
  AddLiquidity
  RemoveLiquidity
  TokenPurchase
  EthPurchase
}
